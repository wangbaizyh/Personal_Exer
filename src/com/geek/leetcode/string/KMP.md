# KMP
## KMP算法应用场景
> 在一个串中查找是否出现过另一个串，这是KMP的看家本领。
## KMP有什么用  
> 解决字符串匹配的问题。
> ***
> KMP的主要思想是：**当出现字符串不匹配时，
> 可以知道一部分之前已经匹配的文本内容，
> 可以利用这些信息避免从头再去做匹配了。**  
> ***
> 重点：**如何记录已经匹配的文本内容，也就是next数组的构建。**
## 什么是前缀表
next数组就是一个前缀表(prefix table)。 
***
前缀表有什么作用呢？  
**前缀表是用来回退的，它记录了模式串与主串(文本串)不匹配的时候，模式串应该从哪里开始重新匹配。**  
***
前缀表是如何记录的呢？  
首先要知道前缀表的任务是当前位置匹配失败，
找到之前已经匹配上的位置，再重新匹配，
此也意味着在某个字符失配时，前缀表会告诉你下一步匹配中，模式串应该跳到哪个位置。  
***
什么是前缀表？  
**记录下标i之前（包括i）的字符串中，有多大长度的相同前缀后缀。**  
## 最长公共前后缀？
> 前缀：指不包含最后一个字符的所有以第一个字符开头的连续子串。  
> 后缀：指不包含第一个字符的所有以最后一个字符结尾的连续子串。  
> 前缀表要求的就是相同前后缀的长度。
## 为什么一定要用前缀表
前缀表具有告诉我们当前位置匹配失败，跳到之前已经匹配过的地方的能力。  
可以看出模式串与前缀表对应位置的数字表示的就是：
**下标i之前（包括i）的字符串中，有多大长度的相同前缀后缀。**  
## 前缀表与next数组
KMP算法都是使用next数组来做回退操作，那么next数组与前缀表有什么关系呢？  
next数组就可以是前缀表。  
## 时间复杂度分析
> 其中n为文本串长度，m为模式串长度，因为在匹配的过程中，
> 根据前缀表不断调整匹配的位置，可以看出匹配的过程是O(n)，
> 之前还要单独生成next数组，时间复杂度是O(m)。
> 所以整个KMP算法的时间复杂度是O(n+m)的。
> ***
> 暴力解法显而易见时间复杂度是O(n × m)，所以
> **KMP在字符串匹配中极大的提高了搜索效率。**
## 构造next数组
定义一个函数getNext来构建next数组，函数参数为指向next数组的指针，和一个字符串。  
**构造next数组其实就是计算模式串s，前缀表的过程。**
主要有如下三步：
1. 初始化
2. 处理前后缀不相同的情况
3. 处理前后缀相同的情况
***
### 初始化
定义两个指针i和j，j指向前缀末尾位置，i指向后缀末尾位置。
然后还要对next数组进行初始化赋值，如下：
```java
int j = -1;
next[0] = j
```
next[i] 表示 i（包括i）之前最长相等的前后缀长度（其实就是j）  
所以初始化next[0] = j 。
### 处理前后缀不相同的情况
因为j初始化为-1，那么i就从1开始，进行s[i] 与 s[j+1]的比较。  
所以遍历模式串s的循环下标i 要从 1 开始，代码如下：
```java
for (int i = 1; i < s.length(); i++) {
```
如果 s[i] 与 s[j+1]不相同，也就是遇到 前后缀末尾不相同的情况，就要向前回退。  
怎么回退呢？  
next[j]就是记录着j（包括j）之前的子串的相同前后缀的长度。  
那么 s[i] 与 s[j+1] 不相同，就要找 j+1前一个元素在next数组里的值（就是next[j]）。  
所以，处理前后缀不相同的情况代码如下：
```java
while (j >= 0 && s[i] != s[j + 1]) { // 前后缀不相同了
    j = next[j]; // 向前回退
}
```
### 处理前后缀相同的情况
如果 s[i] 与 s[j + 1] 相同，那么就同时向后移动i 和j 说明找到了相同的前后缀，
同时还要将j（前缀的长度）赋给next[i], 因为next[i]要记录相同前后缀的长度。  
代码如下：
```java
if (s[i] == s[j + 1]) { // 找到相同的前后缀
    j++;
}
next[i] = j;
```
最后整体构建next数组的函数代码如下：
```java
void getNext(int[] next, String s){
    int j = -1;
    next[0] = j;
    for(int i = 1; i < s.length(); i++) { // 注意i从1开始
        while (j >= 0 && s[i] != s[j + 1]) { // 前后缀不相同了
            j = next[j]; // 向前回退
        }
        if (s[i] == s[j + 1]) { // 找到相同的前后缀
            j++;
        }
        next[i] = j; // 将j（前缀的长度）赋给next[i]
    }
}
```
## 使用next数组来做匹配
遍历文本串与next数组，判断是否已经达到next数组的末尾，减去模式串的长度，即找到文本串字符串中出现模式串的第一个位置。  
## 总结
